import os
import sys
import time
import math

sys.path.append('.')

try:
    # 引入基础库
    import GeomBase
    from GeomBase import *
    from Segment import Segment
    import GeomAlgo

    from StlModel import StlModel
    from Utility import degToRad

    from SliceAlgo import intersectStl_sweep, linkSegs_dlook
    from GenDpPath import genDpPathEx
    from GenSptPath import genSptPath, SptFillType

except ImportError as e:
    print(f"环境错误: {e}")
    sys.exit(1)


# --- 热修复 GeomAlgo (防止报错) ---
def fixed_pointInPolygon(p, polygon):
    n = polygon.count()
    for i in range(n):
        A = polygon.point(i);
        B = polygon.point((i + 1) % n)
        if A.distance(B) < 1e-7: continue
        if GeomAlgo.distance(p, Segment(A, B)) < 1e-7: return -1
    count = 0
    for i in range(n):
        A = polygon.point(i);
        B = polygon.point((i + 1) % n)
        if A.distance(B) < 1e-7: continue
        if (A.y > p.y and B.y > p.y) or (A.y < p.y and B.y < p.y): continue
        if abs(A.y - p.y) < 1e-7 and abs(B.y - p.y) < 1e-7: continue
        if abs(B.y - A.y) > 1e-7:
            x = A.x + (p.y - A.y) * (B.x - A.x) / (B.y - A.y)
            if x > p.x:
                if not (abs(A.y - p.y) < 1e-7 and A.x > p.x) and not (abs(B.y - p.y) < 1e-7 and B.x > p.x): count += 1
    return 1 if count % 2 == 1 else 0


GeomAlgo.pointInPolygon = fixed_pointInPolygon
try:
    import PolyPerSeeker;

    PolyPerSeeker.pointInPolygon = fixed_pointInPolygon
    import SliceAlgo;

    SliceAlgo.pointInPolygon = fixed_pointInPolygon
    import FindSptRegion;

    FindSptRegion.pointInPolygon = fixed_pointInPolygon
except:
    pass


def fix_stl_normals(model):
    count = 0
    for tri in model.triangles:
        tri.calcNormal()
        if tri.N.isZeroVector(): tri.N = Vector3D(0, 0, 1)
        count += 1


def center_model_to_origin(model):
    """模型归中"""
    xMin, xMax, yMin, yMax, zMin, zMax = model.getBounds()
    cx, cy, cz = (xMin + xMax) / 2, (yMin + yMax) / 2, zMin
    trans_mat = Matrix3D.createTranslateMatrix(-cx, -cy, -cz)
    new_model = model.multiplied(trans_mat)
    return new_model


def optimize_path_order(paths, start_pt):
    """路径顺序优化"""
    if not paths: return []
    optimized = []
    remaining = paths[:]
    current_pos = start_pt
    while remaining:
        best_idx = -1
        min_dist = float('inf')
        best_is_reverse = False
        for i, path in enumerate(remaining):
            if path.count() < 2: continue
            p_start, p_end = path.startPoint(), path.endPoint()
            d1, d2 = current_pos.distance(p_start), current_pos.distance(p_end)
            if d1 < min_dist: min_dist, best_idx, best_is_reverse = d1, i, False
            if d2 < min_dist: min_dist, best_idx, best_is_reverse = d2, i, True

        if best_idx != -1:
            best_path = remaining.pop(best_idx)
            if best_is_reverse: best_path.reverse()
            optimized.append(best_path)
            current_pos = best_path.endPoint()
        else:
            remaining.pop(0)
    return optimized

class GCodeGenerator:
    def __init__(self, filename):
        self.filename = filename
        self.lines = []
        self.e_factor = 0.05
        self.current_pos = Point3D(0, 0, 0)
        self.write_header()

    def write_header(self):
        self.lines.append("; Generated by PythonSlicer")
        self.lines.append("G21 ; Millimeter")
        self.lines.append("G90 ; Absolute")
        self.lines.append("M83 ; Relative E")
        self.lines.append("G28 ; Home")
        self.lines.append("G1 Z5.0 F3000")

    def write_layer(self, layer_idx, z, contours, infill, support):
        self.lines.append(f";LAYER:{layer_idx}")
        self.lines.append(f"G0 Z{z:.3f} F3000")

        # 支撑 (Feature Type: SUPPORT)
        if support:
            self.lines.append(";TYPE:SUPPORT")
            for poly in optimize_path_order(support, self.current_pos):
                # 支撑全是打印线，强制 G1
                self._write_solid_path(poly, 2400)

        # 轮廓 (Feature Type: WALL-OUTER)
        if contours:
            self.lines.append(";TYPE:WALL-OUTER")
            for poly in optimize_path_order(contours, self.current_pos):
                # 轮廓全是打印线，强制 G1
                self._write_solid_path(poly, 1200)

        # 填充 (Feature Type: FILL)
        if infill:
            self.lines.append(";TYPE:FILL")
            for poly in optimize_path_order(infill, self.current_pos):
                # 填充包含空走，使用智能判断
                self._write_smart_path(poly, 3000)

    def _write_solid_path(self, poly, speed):
        """强制作为实体打印 (解决轮廓变橙色问题)"""
        if poly.count() < 2: return
        start = poly.startPoint()
        self._travel_to(start)

        for i in range(1, poly.count()):
            p = poly.point(i)
            dist = p.distance(poly.point(i - 1))
            self.lines.append(f"G1 X{p.x:.3f} Y{p.y:.3f} E{dist * self.e_factor:.5f} F{speed}")
        self.current_pos = poly.endPoint()

    def _write_smart_path(self, poly, speed):
        """智能判断空走 (用于填充)"""
        if poly.count() < 2: return
        start = poly.startPoint()
        self._travel_to(start)

        for i in range(1, poly.count()):
            p = poly.point(i)
            prev_p = poly.point(i - 1)
            is_travel = False
            if hasattr(prev_p, 'w') and abs(prev_p.w - 1.0) < 1e-5:
                is_travel = True

            if is_travel:
                self.lines.append(f"G0 X{p.x:.3f} Y{p.y:.3f} F6000")
            else:
                dist = p.distance(prev_p)
                self.lines.append(f"G1 X{p.x:.3f} Y{p.y:.3f} E{dist * self.e_factor:.5f} F{speed}")
        self.current_pos = poly.endPoint()

    def _travel_to(self, p):
        self.lines.append("G1 E-1.0 F2400")  # 回抽
        self.lines.append(f"G0 X{p.x:.3f} Y{p.y:.3f} F6000")
        self.lines.append("G1 E1.0 F2400")  # 恢复

    def save(self):
        with open(self.filename, 'w', encoding='utf-8') as f:
            f.write('\n'.join(self.lines))


def main():

    stl_path = "./STL/bunny.stl"
    if not os.path.exists(stl_path): stl_path = "./STL/bunny.STL"
    if not os.path.exists(stl_path): return

    # 1. 读取 & 修复
    raw_model = StlModel()
    if not raw_model.readStlFile(stl_path): return
    fix_stl_normals(raw_model)  # 必须调用！否则无支撑
    model = center_model_to_origin(raw_model)  # 此时 Point3D 默认 w=1，变换正常

    # 2. 切片
    layers = intersectStl_sweep(model, 0.5)
    for layer in layers:
        if layer.segments: layer.contours = linkSegs_dlook(layer.segments)

    # 3. 支撑生成
    genSptPath(model, layers, pathInvl=1.2, gridSize=0.8, crAngle=degToRad(45), fillType=SptFillType.cross, xyGap=0.2)

    GeomBase.Point3D.__init__.__defaults__ = (0.0, 0.0, 0.0, 0.0)

    # 4. 导出 G代码
    gen = GCodeGenerator("bunny_visual.gcode")

    spt_cnt = 0
    for i, layer in enumerate(layers):
        # 生成填充 (此时产生的点 w=0)
        infill = []
        if layer.contours:
            angle = 0 if i % 2 == 0 else 90
            infill = genDpPathEx(layer.contours, 0.8, degToRad(angle))

        spt = []
        if hasattr(layer, 'sptDpPaths'): spt.extend(layer.sptDpPaths)
        if hasattr(layer, 'sptCpPaths'): spt.extend(layer.sptCpPaths)
        if spt: spt_cnt += 1

        gen.write_layer(i, layer.z, layer.contours, infill, spt)

    gen.save()
    print(f"\n\n[成功] 文件: bunny_visual.gcode")

if __name__ == "__main__":
    main()