import os
import sys
import time
import math

sys.path.append('.')

try:
    import GeomBase
    from GeomBase import *
    from Segment import Segment
    import GeomAlgo
    from StlModel import StlModel
    from Utility import degToRad
    from SliceAlgo import intersectStl_sweep
    from GenDpPath import genDpPathEx
    from GenSptPath import genSptPath, SptFillType
    from ClipperAdaptor import ClipperAdaptor
    from Polyline import Polyline
    from LinkSegs_dlook import LinkSegs_dlook
except ImportError as e:
    print(f"环境错误: {e}")
    sys.exit(1)

def fixed_pointInPolygon(p, polygon):
    n = polygon.count()
    for i in range(n):
        A = polygon.point(i);
        B = polygon.point((i + 1) % n)
        if A.distance(B) < 1e-7: continue
        if GeomAlgo.distance(p, Segment(A, B)) < 1e-7: return -1
    count = 0
    for i in range(n):
        A = polygon.point(i);
        B = polygon.point((i + 1) % n)
        if A.distance(B) < 1e-7: continue
        if (A.y > p.y and B.y > p.y) or (A.y < p.y and B.y < p.y): continue
        if abs(A.y - p.y) < 1e-7 and abs(B.y - p.y) < 1e-7: continue
        if abs(B.y - A.y) > 1e-7:
            x = A.x + (p.y - A.y) * (B.x - A.x) / (B.y - A.y)
            if x > p.x:
                if not (abs(A.y - p.y) < 1e-7 and A.x > p.x) and not (abs(B.y - p.y) < 1e-7 and B.x > p.x): count += 1
    return 1 if count % 2 == 1 else 0


GeomAlgo.pointInPolygon = fixed_pointInPolygon
try:
    import PolyPerSeeker;

    PolyPerSeeker.pointInPolygon = fixed_pointInPolygon
    import SliceAlgo;

    SliceAlgo.pointInPolygon = fixed_pointInPolygon
    import FindSptRegion;

    FindSptRegion.pointInPolygon = fixed_pointInPolygon
except:
    pass

original_init = Point3D.__init__


def new_init(self, x=0.0, y=0.0, z=0.0, w=1.0):
    self.x, self.y, self.z, self.w = x, y, z, w


Point3D.__init__ = new_init


def fix_stl_normals(model):
    count = 0
    for tri in model.triangles:
        tri.calcNormal()
        if tri.N.isZeroVector(): tri.N = Vector3D(0, 0, 1)
        count += 1


def center_model_to_origin(model):
    xMin, xMax, yMin, yMax, zMin, zMax = model.getBounds()
    cx, cy, cz = (xMin + xMax) / 2, (yMin + yMax) / 2, zMin
    trans_mat = Matrix3D.createTranslateMatrix(-cx, -cy, -cz)
    return model.multiplied(trans_mat)


def force_close_contours(layer):
    if not layer.segments: return
    linker = LinkSegs_dlook(layer.segments)
    valid_contours = list(linker.contours)

    if linker.polys:
        for open_poly in linker.polys:
            if open_poly.count() > 3:
                open_poly.addPoint(open_poly.startPoint())
                valid_contours.append(open_poly)

    if valid_contours:
        ca = ClipperAdaptor()
        layer.contours = ca.simplify_and_clean(valid_contours, clean_dist=0.02)
    else:
        layer.contours = []


def optimize_path_order(paths, start_pt):
    if not paths: return []
    optimized = []
    remaining = paths[:]
    curr = start_pt

    while remaining:
        best_idx = -1;
        min_dist = float('inf');
        reverse = False
        for i, p in enumerate(remaining):
            if p.count() < 2: continue
            d1 = curr.distance(p.startPoint())
            d2 = curr.distance(p.endPoint())
            if d1 < min_dist: min_dist, best_idx, reverse = d1, i, False
            if d2 < min_dist: min_dist, best_idx, reverse = d2, i, True

        if best_idx != -1:
            path = remaining.pop(best_idx)
            if reverse: path.reverse()
            optimized.append(path)
            curr = path.endPoint()
        else:
            remaining.pop(0)
    return optimized


class GCodeGenerator:
    def __init__(self, filename):
        self.filename = filename
        self.lines = []
        self.e_factor = 0.05
        self.current_pos = Point3D(0, 0, 0)
        self.write_header()

    def write_header(self):
        self.lines.append("; Generated by PythonSlicer (Bunny Fixed)")
        self.lines.append("G21 ; mm")
        self.lines.append("G90 ; Abs pos")
        self.lines.append("M83 ; Rel E")
        self.lines.append("G28 ; Home")
        self.lines.append("G1 Z5.0 F3000")

    def write_layer(self, layer_idx, z, contours, infill, support):
        self.lines.append(f";LAYER:{layer_idx}")
        self.lines.append(f"G0 Z{z:.3f} F3000")

        # 1. 支撑
        if support:
            self.lines.append(";TYPE:SUPPORT")
            for poly in optimize_path_order(support, self.current_pos):
                self._write_solid_path(poly, 2400)

        # 2. 轮廓
        if contours:
            self.lines.append(";TYPE:WALL-OUTER")
            for poly in optimize_path_order(contours, self.current_pos):
                self._write_solid_path(poly, 1200)

        # 3. 填充
        if infill:
            self.lines.append(";TYPE:FILL")
            for poly in optimize_path_order(infill, self.current_pos):
                self._write_smart_path(poly, 3000)

    def _write_solid_path(self, poly, speed):
        if poly.count() < 2: return
        start = poly.startPoint()
        self._travel_to(start)

        for i in range(1, poly.count()):
            p = poly.point(i)
            dist = p.distance(poly.point(i - 1))
            self.lines.append(f"G1 X{p.x:.3f} Y{p.y:.3f} E{dist * self.e_factor:.5f} F{speed}")
        self.current_pos = poly.endPoint()

    def _write_smart_path(self, poly, speed):
        if poly.count() < 2: return
        start = poly.startPoint()
        self._travel_to(start)

        for i in range(1, poly.count()):
            p = poly.point(i)
            prev = poly.point(i - 1)

            is_travel = False
            if hasattr(prev, 'w') and abs(prev.w - 1.0) < 1e-5:
                is_travel = True

            if is_travel:
                self.lines.append(f"G0 X{p.x:.3f} Y{p.y:.3f} F6000")
            else:
                dist = p.distance(prev)
                self.lines.append(f"G1 X{p.x:.3f} Y{p.y:.3f} E{dist * self.e_factor:.5f} F{speed}")
        self.current_pos = poly.endPoint()

    def _travel_to(self, p):
        self.lines.append("G1 E-1.0 F2400")  # 回抽
        self.lines.append(f"G0 X{p.x:.3f} Y{p.y:.3f} F6000")
        self.lines.append("G1 E1.0 F2400")  # 恢复

    def save(self):
        with open(self.filename, 'w', encoding='utf-8') as f:
            f.write('\n'.join(self.lines))


def main():
    print("=" * 60)
    print(" G代码生成")
    print("=" * 60)

    stl_path = "./STL/bunny.stl"
    if not os.path.exists(stl_path): stl_path = "./STL/bunny.STL"
    if not os.path.exists(stl_path):
        print("错误：找不到 bunny.stl")
        return

    # 1. 读取 & 归中
    raw_model = StlModel()
    if not raw_model.readStlFile(stl_path): return
    fix_stl_normals(raw_model)
    model = center_model_to_origin(raw_model)

    # 2. 切片 (0.5mm)
    layers = intersectStl_sweep(model, 0.5)

    # 3. 修复轮廓
    for layer in layers:
        if layer.segments:
            force_close_contours(layer)

    # 4. 生成支撑
    genSptPath(model, layers, pathInvl=1.2, gridSize=2.0,
               crAngle=degToRad(60), fillType=SptFillType.cross, xyGap=0.5)

    # 5. 生成 G代码
    print("写入 G代码...")
    gen = GCodeGenerator("bunny_final.gcode")

    for i, layer in enumerate(layers):
        infill = []
        if layer.contours:
            angle = 0 if i % 2 == 0 else 90
            infill = genDpPathEx(layer.contours, 0.8, degToRad(angle))

        spt = []
        if hasattr(layer, 'sptDpPaths'): spt.extend(layer.sptDpPaths)
        if hasattr(layer, 'sptCpPaths'): spt.extend(layer.sptCpPaths)

        gen.write_layer(i, layer.z, layer.contours, infill, spt)

    gen.save()
    print(f"\n\n[成功] 文件已生成: bunny_final.gcode")


if __name__ == "__main__":
    main()